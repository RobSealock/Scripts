# WinHostBaseline.Collectors.psm1
Set-StrictMode -Version Latest
Import-Module "$PSScriptRoot\WinHostBaselineCore.psm1" -ErrorAction Stop

function Resolve-DllPath {
    param([string]$NameOrPath)

    if ([string]::IsNullOrWhiteSpace($NameOrPath)) { return $null }

    $raw = $NameOrPath.Trim().Trim('"')
    $p = Normalize-PathSafe $raw

    if ($p -and ($p -match '\\')) {
        if (Test-Path -LiteralPath $p) { return $p }
        $rawName = [System.IO.Path]::GetFileName($p)
        if ($rawName) { $raw = $rawName }
    }

    $name = $raw
    if (-not $name.ToLower().EndsWith('.dll')) { $name = "$name.dll" }

    $candidates = @(
        (Join-Path $env:SystemRoot "System32\$name"),
        (Join-Path $env:SystemRoot "SysWOW64\$name"),
        (Join-Path $env:SystemRoot $name)
    )

    foreach ($c in $candidates) {
        try {
            if (Test-Path -LiteralPath $c) { return (Get-Item -LiteralPath $c).FullName }
        } catch {}
    }

    return Normalize-PathSafe $raw
}

function Get-ServicesHostItems {
    Get-CimInstance Win32_Service | ForEach-Object {
        $exe = Extract-ExePath $_.PathName
        [HostItem]@{
            Key      = "Service:$($_.Name)"
            Category = 'Services'
            Identity = [HostIdentity]@{
                Path        = $exe
                CommandLine = $_.PathName
                Sha256      = Get-FileHashSafe $exe
            }
            Signature = Get-SignatureSafe $exe
            Metadata  = @{
                Name        = $_.Name
                DisplayName = $_.DisplayName
                State       = $_.State
                StartMode   = $_.StartMode
                StartName   = $_.StartName
                ServiceType = $_.ServiceType
            }
        }
    }
}

function Get-DriversHostItems {
    Get-CimInstance Win32_SystemDriver | ForEach-Object {
        $exe = Extract-ExePath $_.PathName
        [HostItem]@{
            Key      = "Driver:$($_.Name)"
            Category = 'Drivers'
            Identity = [HostIdentity]@{
                Path        = $exe
                CommandLine = $_.PathName
                Sha256      = Get-FileHashSafe $exe
            }
            Signature = Get-SignatureSafe $exe
            Metadata  = @{
                Name        = $_.Name
                State       = $_.State
                StartMode   = $_.StartMode
                ServiceType = $_.ServiceType
            }
        }
    }
}

function Get-ProcessesHostItems {
    <#
    .SYNOPSIS
        Collect running processes. Keys are stable and collision-resistant.

    .NOTES
        Key is based on Name + normalized executable path + SHA256(CommandLine).
        Multiple instances with the same Name/Path/CommandLine are aggregated into one item.
    #>

    $items = @()

    # Local helper: SHA256 hash of a string (PowerShell 5.1 compatible)
    function Get-StringSha256 {
        param([string]$InputString)
        if ($null -eq $InputString) { return '<null>' }
        $s = $InputString.Trim()
        if ($s.Length -eq 0) { return '<empty>' }
        $sha = [System.Security.Cryptography.SHA256]::Create()
        try {
            $bytes = [System.Text.Encoding]::UTF8.GetBytes($s)
            $hash  = $sha.ComputeHash($bytes)
            return -join ($hash | ForEach-Object { $_.ToString('x2') })
        } finally {
            if ($sha) { $sha.Dispose() }
        }
    }

    $groups = @{}

    Get-CimInstance Win32_Process -ErrorAction SilentlyContinue | ForEach-Object {
        $p = $_
        $path = Normalize-PathSafe $p.ExecutablePath
        $keyPath = if ($path) { $path } else { '<noimage>' }

        $cmd = [string]$p.CommandLine
        $cmdHash = Get-StringSha256 $cmd

        $key = "Process:$($p.Name)|$keyPath|$cmdHash"
        if (-not $groups.ContainsKey($key)) { $groups[$key] = @() }
        $groups[$key] += $p
    }

    foreach ($k in $groups.Keys) {
        $plist = $groups[$k]
        if (-not $plist -or $plist.Count -lt 1) { continue }

        $first = $plist[0]
        $path = Normalize-PathSafe $first.ExecutablePath
        $cmd  = [string]$first.CommandLine
        $cmdHash = Get-StringSha256 $cmd

        $pids = @($plist | ForEach-Object { [int]$_.ProcessId }) | Sort-Object -Unique
        $ppids = @($plist | ForEach-Object { [int]$_.ParentProcessId }) | Sort-Object -Unique

        $items += [HostItem]@{
            Key      = $k
            Category = 'Processes'
            Identity = [HostIdentity]@{
                Path        = $path
                CommandLine = $cmd
                Sha256      = Get-FileHashSafe $path
            }
            Signature = Get-SignatureSafe $path
            Metadata  = @{
                Name             = $first.Name
                CommandLineHash  = $cmdHash
                ProcessIds       = $pids
                ParentProcessIds = $ppids
                Count            = $pids.Count
            }
        }
    }

    $items
}

function Get-ScheduledTasksHostItems {
    Get-ScheduledTask | ForEach-Object {
        $tinfo   = $_ | Get-ScheduledTaskInfo
        $actions = @()

        foreach ($a in $_.Actions) {
            $exec = Normalize-PathSafe $a.Execute
            $exe  = Extract-ExePath $exec
            $actions += @{
                Type       = $a.GetType().Name
                Execute    = $exec
                Arguments  = $a.Arguments
                WorkingDir = $a.WorkingDirectory
                ExePath    = $exe
                Signature  = Get-SignatureSafe $exe
            }
        }

        $primary = $actions | Where-Object { $_.ExePath -and (Test-Path -LiteralPath $_.ExePath) } | Select-Object -First 1
        $primaryPath = if ($primary) { $primary.ExePath } else { '' }
        $primaryCmd  = if ($primary) {
            if ($primary.Arguments) { "$($primary.ExePath) $($primary.Arguments)" } else { "$($primary.ExePath)" }
        } else { '' }

        # Compute CommandLineHash over all actions
        $allCmd = ($actions | ForEach-Object {
            if ($_.ExePath) {
                if ($_.Arguments) { "$($_.ExePath) $($_.Arguments)" } else { "$($_.ExePath)" }
            } else { '' }
        }) -join ' ; '

        $cmdHash = $null
        if ($allCmd) {
            $sha = [System.Security.Cryptography.SHA256]::Create()
            try {
                $bytes = [System.Text.Encoding]::UTF8.GetBytes($allCmd)
                $cmdHash = ($sha.ComputeHash($bytes) | ForEach-Object { $_.ToString('x2') }) -join ''
            } finally {
                if ($sha) { $sha.Dispose() }
            }
        }

        [HostItem]@{
            Key      = "Task:$($_.TaskPath)|$($_.TaskName)"
            Category = 'ScheduledTasks'
            Identity = [HostIdentity]@{
                Path        = $primaryPath
                CommandLine = $primaryCmd
                Sha256      = Get-FileHashSafe $primaryPath
            }
            Signature = Get-SignatureSafe $primaryPath
            Metadata  = @{
                TaskName       = $_.TaskName
                TaskPath       = $_.TaskPath
                State          = $tinfo.State.ToString()
                LastRunTime    = $tinfo.LastRunTime
                NextRunTime    = $tinfo.NextRunTime
                Author         = $_.Author
                Description    = $_.Description
                Principal      = $_.Principal.UserId
                RunLevel       = $_.Principal.RunLevel.ToString()
                Actions        = $actions
                CommandLineHash= $cmdHash
            }
        }
    }
}

function Get-StartupHostItems {
    <#
    .SYNOPSIS
        Collect common startup persistence locations (Run/RunOnce + Startup folders).

    .PARAMETER AllProfiles
        Opt-in. If set, attempts to scan Run/RunOnce for ALL local user profiles by loading user hives.
        Default behavior scans HKLM plus HKCU and any currently LOADED user hives under HKEY_USERS.

        NOTE: Loading user hives requires administrative rights and may fail for locked profiles.
    #>
    param(
        [switch]$AllProfiles
    )

    $items = @()

    function Add-RunKeyItems {
        param(
            [string]$RunKeyPath,
            [string]$Sid = '',
            [string]$HiveSource = ''
        )

        try { $props = Get-ItemProperty -Path $RunKeyPath -ErrorAction Stop } catch { return }

        foreach ($p in $props.PSObject.Properties | Where-Object { $_.Name -notmatch '^PS' }) {
            $val = [string]$p.Value
            if ([string]::IsNullOrWhiteSpace($val)) { continue }

            $exe = Extract-ExePath $val
            $items += [HostItem]@{
                Key      = "Startup:REG:$RunKeyPath\$($p.Name)"
                Category = 'Startup'
                Identity = [HostIdentity]@{
                    Path        = $exe
                    CommandLine = $val
                    Sha256      = Get-FileHashSafe $exe
                }
                Signature = Get-SignatureSafe $exe
                Metadata  = @{
                    Source          = 'Registry'
                    RegistryPath    = $RunKeyPath
                    ValueName       = $p.Name
                    CollectedFromSid= $Sid
                    HiveSource      = $HiveSource
                }
            }
        }
    }

    # 1) HKLM Run keys
    $hklmKeys = @(
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run",
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce",
        "HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Run"
    )
    foreach ($rk in $hklmKeys) { Add-RunKeyItems -RunKeyPath $rk -HiveSource 'HKLM' }

    # 2) Current token HKCU (note: elevated HKCU refers to the elevated identity)
    $hkcuKeys = @(
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run",
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce"
    )
    $curSid = ''
    try { $curSid = [System.Security.Principal.WindowsIdentity]::GetCurrent().User.Value } catch { $curSid = '' }
    foreach ($rk in $hkcuKeys) { Add-RunKeyItems -RunKeyPath $rk -Sid $curSid -HiveSource 'HKCU' }

    # 3) Scan currently LOADED user hives under HKU (covers other logged-on users)
    try {
        $loadedSids = Get-ChildItem Registry::HKEY_USERS -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -match 'HKEY_USERS\\S-1-5-21-' } |
            ForEach-Object { $_.PSChildName } | Sort-Object -Unique

        foreach ($sid in $loadedSids) {
            foreach ($sub in @(
                "Software\Microsoft\Windows\CurrentVersion\Run",
                "Software\Microsoft\Windows\CurrentVersion\RunOnce"
            )) {
                $rk = "Registry::HKEY_USERS\$sid\$sub"
                Add-RunKeyItems -RunKeyPath $rk -Sid $sid -HiveSource 'HKU(loaded)'
            }
        }
    } catch { }

    # 4) Optional: scan ALL local profiles by loading NTUSER.DAT (admin required)
    if ($AllProfiles) {
        try {
            $profiles = Get-CimInstance Win32_UserProfile -ErrorAction SilentlyContinue |
                Where-Object { $_.LocalPath -and $_.SID -and (-not $_.Special) }

            foreach ($prof in $profiles) {
                $sid = [string]$prof.SID
                if ([string]::IsNullOrWhiteSpace($sid)) { continue }

                $hkuPath = "Registry::HKEY_USERS\$sid"
                $isLoaded = $false
                try { $isLoaded = Test-Path $hkuPath } catch { $isLoaded = $false }

                $didLoad = $false
                if (-not $isLoaded) {
                    $ntuser = Join-Path $prof.LocalPath "NTUSER.DAT"
                    if (Test-Path -LiteralPath $ntuser) {
                        # reg.exe is used for compatibility and simplicity in PS 5.1
                        $null = & reg.exe load "HKU\$sid" "$ntuser" 2>$null
                        $didLoad = $true
                    } else {
                        continue
                    }
                }

                try {
                    foreach ($sub in @(
                        "Software\Microsoft\Windows\CurrentVersion\Run",
                        "Software\Microsoft\Windows\CurrentVersion\RunOnce"
                    )) {
                        $rk = "Registry::HKEY_USERS\$sid\$sub"
                        Add-RunKeyItems -RunKeyPath $rk -Sid $sid -HiveSource 'HKU(loaded-via-AllProfiles)'
                    }
                } finally {
                    if ($didLoad) {
                        $null = & reg.exe unload "HKU\$sid" 2>$null
                    }
                }
            }
        } catch { }
    }

    # 5) Startup folders (existing behavior)
    $startupFolders = @(
        (Join-Path $env:ProgramData "Microsoft\Windows\Start Menu\Programs\StartUp"),
        (Join-Path $env:APPDATA "Microsoft\Windows\Start Menu\Programs\Startup")
    )

    foreach ($sf in $startupFolders) {
        if (-not (Test-Path $sf)) { continue }

        $rootType = if ($sf -like "$($env:ProgramData)*") { 'ProgramData' } else { 'User' }

        Get-ChildItem $sf -File -ErrorAction SilentlyContinue | ForEach-Object {
            $items += [HostItem]@{
                Key      = "Startup:Folder:$rootType|$($_.Name)"
                Category = 'Startup'
                Identity = [HostIdentity]@{
                    Path        = $_.FullName
                    CommandLine = $_.FullName
                    Sha256      = Get-FileHashSafe $_.FullName
                }
                Signature = Get-SignatureSafe $_.FullName
                Metadata  = @{
                    Source   = 'StartupFolder'
                    Location = $sf
                    Name     = $_.Name
                }
            }
        }
    }

    $items
}

function Get-NetworkSocketsHostItems {
    param([switch]$IncludeRemoteSockets)

    $procs = @{}
    Get-CimInstance Win32_Process | ForEach-Object { $procs[[int]$_.ProcessId] = $_ }

    $items = @()

    Get-NetTCPConnection -ErrorAction SilentlyContinue | ForEach-Object {
        if (-not $IncludeRemoteSockets) {
            if ($_.State.ToString() -ne 'Listen') { continue }
        }

        $pid = [int]$_.OwningProcess
        $p   = $procs[$pid]
        $img = if ($p) { Normalize-PathSafe $p.ExecutablePath } else { $null }
        $exeKey = if ($img) { $img } else { '<noimage>' }

        $key =
            if ($IncludeRemoteSockets) {
                "TCP:$($_.LocalAddress):$($_.LocalPort)->$($_.RemoteAddress):$($_.RemotePort)|$exeKey"
            } else {
                "TCP-LISTEN:$($_.LocalAddress):$($_.LocalPort)|$exeKey"
            }

        $items += [HostItem]@{
            Key      = $key
            Category = 'NetworkSockets'
            Identity = [HostIdentity]@{
                Path        = $img
                CommandLine = if ($p) { $p.CommandLine } else { '' }
                Sha256      = Get-FileHashSafe $img
            }
            Signature = Get-SignatureSafe $img
            Metadata  = @{
                Protocol    = 'TCP'
                Local       = "$($_.LocalAddress):$($_.LocalPort)"
                Remote      = if ($IncludeRemoteSockets) { "$($_.RemoteAddress):$($_.RemotePort)" } else { '' }
                State       = $_.State.ToString()
                ProcessId   = $pid
                ProcessName = if ($p) { $p.Name } else { '' }
            }
        }
    }

    Get-NetUDPEndpoint -ErrorAction SilentlyContinue | ForEach-Object {
        $pid = [int]$_.OwningProcess
        $p   = $procs[$pid]
        $img = if ($p) { Normalize-PathSafe $p.ExecutablePath } else { $null }
        $exeKey = if ($img) { $img } else { '<noimage>' }

        $items += [HostItem]@{
            Key      = "UDP:$($_.LocalAddress):$($_.LocalPort)|$exeKey"
            Category = 'NetworkSockets'
            Identity = [HostIdentity]@{
                Path        = $img
                CommandLine = if ($p) { $p.CommandLine } else { '' }
                Sha256      = Get-FileHashSafe $img
            }
            Signature = Get-SignatureSafe $img
            Metadata  = @{
                Protocol    = 'UDP'
                Local       = "$($_.LocalAddress):$($_.LocalPort)"
                Remote      = ''
                State       = ''
                ProcessId   = $pid
                ProcessName = if ($p) { $p.Name } else { '' }
            }
        }
    }

    $items
}

function Get-WmiPersistenceHostItems {
    $ns = "root\subscription"
    $items = @()

    Get-CimInstance -Namespace $ns -ClassName __EventFilter -ErrorAction SilentlyContinue | ForEach-Object {
        $items += [HostItem]@{
            Key      = "WMI.Filter:$($_.Name)"
            Category = 'WMI.Filter'
            Identity = [HostIdentity]@{ Path=''; CommandLine=''; Sha256='' }
            Signature = [HostSignature]@{
                Status='N/A';Signer='';Thumbprint='';
                IsMicrosoft=$false;IsSysinternals=$false;IsUserWritable=$false
            }
            Metadata  = @{
                Name           = $_.Name
                Query          = $_.Query
                QueryLanguage  = $_.QueryLanguage
                EventNamespace = $_.EventNamespace
            }
        }
    }

    Get-CimInstance -Namespace $ns -ClassName CommandLineEventConsumer -ErrorAction SilentlyContinue | ForEach-Object {
        $cmd = $_.CommandLineTemplate
        $exe = Extract-ExePath $cmd
        $items += [HostItem]@{
            Key      = "WMI.Consumer:$($_.Name)"
            Category = 'WMI.Consumer'
            Identity = [HostIdentity]@{
                Path        = $exe
                CommandLine = $cmd
                Sha256      = Get-FileHashSafe $exe
            }
            Signature = Get-SignatureSafe $exe
            Metadata  = @{ Name = $_.Name }
        }
    }

    # ActiveScriptEventConsumer (common fileless persistence)
    Get-CimInstance -Namespace $ns -ClassName ActiveScriptEventConsumer -ErrorAction SilentlyContinue | ForEach-Object {
        $scriptText = [string]$_.ScriptText
        $engine = [string]$_.ScriptingEngine

        $items += [HostItem]@{
            Key      = "WMI.Consumer.ActiveScript:$($_.Name)"
            Category = 'WMI.Consumer.ActiveScript'
            Identity = [HostIdentity]@{ Path=''; CommandLine=''; Sha256='' }
            Signature = [HostSignature]@{
                Status='N/A';Signer='';Thumbprint='';
                IsMicrosoft=$false;IsSysinternals=$false;IsUserWritable=$false
            }
            Metadata  = @{
                Name           = $_.Name
                ScriptingEngine= $engine
                ScriptText     = $scriptText
            }
        }
    }

    Get-CimInstance -Namespace $ns -ClassName __FilterToConsumerBinding -ErrorAction SilentlyContinue | ForEach-Object {
        $filterStr   = $_.Filter.ToString().Trim().ToLowerInvariant()
        $consumerStr = $_.Consumer.ToString().Trim().ToLowerInvariant()

        $items += [HostItem]@{
            Key      = "WMI.Binding:$filterStr->$consumerStr"
            Category = 'WMI.Binding'
            Identity = [HostIdentity]@{ Path=''; CommandLine=''; Sha256='' }
            Signature = [HostSignature]@{
                Status='N/A';Signer='';Thumbprint='';
                IsMicrosoft=$false;IsSysinternals=$false;IsUserWritable=$false
            }
            Metadata  = @{
                Filter   = $filterStr
                Consumer = $consumerStr
            }
        }
    }

    $items
}

function Get-COMHostItems {
    $items = @()

    $roots = @(
        "HKCR:\CLSID",
        "HKCU:\Software\Classes\CLSID"
    )

    foreach ($root in $roots) {
        if (-not (Test-Path $root)) { continue }

        Get-ChildItem $root -ErrorAction SilentlyContinue | ForEach-Object {
            $clsid = $_.PSChildName
            $inproc = Join-Path $_.PSPath "InprocServer32"
            $local  = Join-Path $_.PSPath "LocalServer32"

            foreach ($pathKey in @($inproc, $local)) {
                if (-not (Test-Path $pathKey)) { continue }

                try { $val = (Get-ItemProperty -Path $pathKey -ErrorAction Stop)."(default)" }
                catch { continue }

                $exe = Extract-ExePath $val
                $exeKey = if ($exe) { $exe } else { '<noexe>' }

                $items += [HostItem]@{
                    Key      = "COM:$clsid"
                    Category = 'COM'
                    Identity = [HostIdentity]@{
                        Path        = $exe
                        CommandLine = $val
                        Sha256      = Get-FileHashSafe $exe
                    }
                    Signature = Get-SignatureSafe $exe
                    Metadata  = @{
                        CLSID      = $clsid
                        Registry   = $pathKey
                        RawValue   = $val
                        Type       = if ($pathKey -like '*Inproc*') { 'InprocServer32' } else { 'LocalServer32' }
                    }
                }
            }
        }
    }

    $items
}

function Get-LSAHostItems {
    $items = @()
    $key = "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa"

    try { $props = Get-ItemProperty -Path $key -ErrorAction Stop }
    catch { return @() }

    foreach ($field in @("Authentication Packages","Security Packages","Notification Packages")) {
        $vals = $props.$field
        if (-not $vals) { continue }

        foreach ($dll in $vals) {
            $resolved = Resolve-DllPath $dll

            $items += [HostItem]@{
                Key      = "LSA:$field|$dll"
                Category = 'LSA'
                Identity = [HostIdentity]@{
                    Path        = $resolved
                    CommandLine = [string]$dll
                    Sha256      = Get-FileHashSafe $resolved
                }
                Signature = Get-SignatureSafe $resolved
                Metadata  = @{
                    Field        = $field
                    Raw          = [string]$dll
                    ResolvedPath = $resolved
                }
            }
        }
    }

    $items
}

function Get-WinsockHostItems {
    $items = @()

    $key = "HKLM:\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters\Protocol_Catalog9"
    if (-not (Test-Path $key)) { return @() }

    try { $entries = Get-ItemProperty -Path $key -ErrorAction Stop }
    catch { return @() }

    if (-not $entries.Catalog_Entries) { return @() }

    foreach ($entry in $entries.Catalog_Entries) {
        try {
            if (-not $entry) { continue }
            if (-not ($entry.PSObject.Properties.Name -contains 'LibraryPath')) { continue }

            $dll = [string]$entry.LibraryPath
            if ([string]::IsNullOrWhiteSpace($dll)) { continue }

            $exe = Normalize-PathSafe $dll

            $items += [HostItem]@{
                Key      = "Winsock:$dll"
                Category = 'Winsock'
                Identity = [HostIdentity]@{
                    Path        = $exe
                    CommandLine = $dll
                    Sha256      = Get-FileHashSafe $exe
                }
                Signature = Get-SignatureSafe $exe
                Metadata  = @{
                    EntryId     = $entry.CatalogEntryId
                    DisplayName = $entry.DisplayString
                }
            }
        } catch {
            continue
        }
    }

    $items
}

function Get-BrowserExtensionsHostItems {
    <#
    .SYNOPSIS
        Enumerate browser extensions.

    .DESCRIPTION
        By default, enumerates Chrome and Edge extensions across ALL Chromium profiles
        under each browser's "User Data" directory (e.g., Default, Profile 1, Profile 2).

    .PARAMETER Firefox
        Opt-in. If set, also enumerates Firefox profiles/extensions.

    .NOTES
        For Chromium extensions, the Identity.Path points to manifest.json (when present) for hashing.
    #>
    param(
        [switch]$Firefox
    )

    $items = @()

    function Add-ChromiumExtensions {
        param(
            [string]$BrowserName,
            [string]$UserDataRoot
        )

        if (-not (Test-Path -LiteralPath $UserDataRoot)) { return }

        $profiles = Get-ChildItem -LiteralPath $UserDataRoot -Directory -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -eq 'Default' -or $_.Name -like 'Profile *' -or $_.Name -like 'Guest Profile' }

        foreach ($prof in $profiles) {
            $extRoot = Join-Path $prof.FullName "Extensions"
            if (-not (Test-Path -LiteralPath $extRoot)) { continue }

            Get-ChildItem -LiteralPath $extRoot -Directory -ErrorAction SilentlyContinue | ForEach-Object {
                $extId = $_.Name

                # Versions are subfolders of extension id
                $verDirs = Get-ChildItem -LiteralPath $_.FullName -Directory -ErrorAction SilentlyContinue |
                    Sort-Object @{ Expression = { 
                        $v = $null
                        if ([System.Version]::TryParse($_.Name, [ref]$v)) { $v } else { [version]'0.0.0.0' }
                    } } -Descending, Name -Descending

                $latestVer = if ($verDirs -and $verDirs.Count -gt 0) { $verDirs[0].Name } else { '' }
                $manifestPath = $null
                if ($latestVer) {
                    $mp = Join-Path (Join-Path $_.FullName $latestVer) "manifest.json"
                    if (Test-Path -LiteralPath $mp) { $manifestPath = $mp }
                }

                $key = "Browser:$BrowserName|Profile:$($prof.Name)|Ext:$extId"
                $hashTarget = if ($manifestPath) { $manifestPath } else { $_.FullName }

                $items += [HostItem]@{
                    Key      = $key
                    Category = 'Browser'
                    Identity = [HostIdentity]@{
                        Path        = $hashTarget
                        CommandLine = ''
                        Sha256      = Get-FileHashSafe $hashTarget
                    }
                    Signature = (if ($manifestPath) { Get-SignatureSafe $hashTarget } else { [HostSignature]@{ Status='N/A';Signer='';Thumbprint='';IsMicrosoft=$false;IsSysinternals=$false;IsUserWritable=(Is-UserWritablePath $hashTarget) } })
                    Metadata  = @{
                        Browser       = $BrowserName
                        Profile       = $prof.Name
                        ExtensionId   = $extId
                        LatestVersion = $latestVer
                        Versions      = @($verDirs | ForEach-Object { $_.Name })
                        Manifest      = $manifestPath
                        Root          = $_.FullName
                    }
                }
            }
        }
    }

    $chromeUserData = Join-Path $env:LOCALAPPDATA "Google\Chrome\User Data"
    $edgeUserData   = Join-Path $env:LOCALAPPDATA "Microsoft\Edge\User Data"

    Add-ChromiumExtensions -BrowserName 'Chrome' -UserDataRoot $chromeUserData
    Add-ChromiumExtensions -BrowserName 'Edge'   -UserDataRoot $edgeUserData

    if ($Firefox) {
        <#
            Firefox enumeration (opt-in):
            - Parses extensions.json per profile to list installed add-ons.
            - Attempts to locate the backing XPI on disk for per-addon hashing.
        #>
        $ffProfiles = Join-Path $env:APPDATA "Mozilla\Firefox\Profiles"
        if (Test-Path -LiteralPath $ffProfiles) {
            Get-ChildItem -LiteralPath $ffProfiles -Directory -ErrorAction SilentlyContinue | ForEach-Object {
                $prof = $_
                $extJson = Join-Path $prof.FullName "extensions.json"

                if (-not (Test-Path -LiteralPath $extJson)) {
                    return
                }

                $jsonObj = $null
                try {
                    $jsonObj = (Get-Content -LiteralPath $extJson -Raw -ErrorAction Stop) | ConvertFrom-Json -ErrorAction Stop
                } catch {
                    # Fall back to a profile integrity item if parsing fails
                    $items += [HostItem]@{
                        Key      = "Browser:Firefox|Profile:$($prof.Name)|ExtensionsJson"
                        Category = 'Browser'
                        Identity = [HostIdentity]@{
                            Path        = $extJson
                            CommandLine = ''
                            Sha256      = Get-FileHashSafe $extJson
                        }
                        Signature = Get-SignatureSafe $extJson
                        Metadata  = @{
                            Browser      = 'Firefox'
                            Profile      = $prof.Name
                            ExtensionsJson = $extJson
                            Root         = $prof.FullName
                            ParseError   = $true
                        }
                    }
                    return
                }

                $addons = @()
                try { $addons = @($jsonObj.addons) } catch { $addons = @() }

                foreach ($a in $addons) {
                    if (-not $a) { continue }
                    $id = $a.id
                    if ([string]::IsNullOrWhiteSpace($id)) { continue }

                    $name = $a.defaultLocale.name
                    $ver  = $a.version
                    $type = $a.type

                    # Try to locate backing XPI (best-effort)
                    $xpi = $null
                    if ($a.path -and (Test-Path -LiteralPath $a.path)) {
                        $xpi = $a.path
                    } else {
                        $cand1 = Join-Path (Join-Path $prof.FullName "extensions") ($id + ".xpi")
                        $cand2 = Join-Path (Join-Path $prof.FullName "extensions") $id
                        if (Test-Path -LiteralPath $cand1) { $xpi = $cand1 }
                        elseif (Test-Path -LiteralPath $cand2) { $xpi = $cand2 }
                    }

                    $key = "Browser:Firefox|Profile:$($prof.Name)|Addon:$id"
                    $hashTarget = if ($xpi) { $xpi } else { $extJson }

                    $items += [HostItem]@{
                        Key      = $key
                        Category = 'Browser'
                        Identity = [HostIdentity]@{
                            Path        = $hashTarget
                            CommandLine = ''
                            Sha256      = Get-FileHashSafe $hashTarget
                        }
                        Signature = (if ($xpi) { Get-SignatureSafe $hashTarget } else { Get-SignatureSafe $extJson })
                        Metadata  = @{
                            Browser     = 'Firefox'
                            Profile     = $prof.Name
                            ExtensionId = $id
                            Name        = $name
                            Version     = $ver
                            Type        = $type
                            XpiPath     = $xpi
                            ExtensionsJson = $extJson
                        }
                    }
                }
            }
        }
    }

    $items
}
