# WinHostBaseline.ps1
<#+
.SYNOPSIS
    Generate a host snapshot and compare it to a saved baseline.

.PARAMETER AllProfiles
    Opt-in. Load and scan all local user profile hives for HKU Run/RunOnce keys.

.PARAMETER ResolveNetworkPaths
    Opt-in. Attempt to resolve UNC and mapped-drive paths (may hang if unreachable).

.PARAMETER Firefox
    Opt-in. Enumerate Firefox profile extensions.
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)][string]$Mode,
    [string]$OutputDir = 'C:\Temp\Scan\Output\',
    [string]$RefDir    = 'C:\Temp\Scan\Ref\',

    # Include established TCP connections and UDP remote endpoints (not just LISTEN).
    [switch]$IncludeRemoteSockets,

    # Opt-in: scan Run/RunOnce for ALL local profiles by loading user hives (admin required).
    [switch]$AllProfiles,

    # Opt-in: allow Normalize-PathSafe to resolve UNC / mapped drives (may hang if unreachable).
    [switch]$ResolveNetworkPaths,

    # Opt-in: also enumerate Firefox profiles/extensions.
    [switch]$Firefox
)

Set-StrictMode -Version Latest

Import-Module "$PSScriptRoot\WinHostBaselineCore.psm1" -ErrorAction Stop
Import-Module "$PSScriptRoot\WinHostBaseline.Collectors.psm1" -ErrorAction Stop

Set-WinHostBaselineOptions -ResolveNetworkPaths:$ResolveNetworkPaths

function Test-IsAdmin {
    $id = [Security.Principal.WindowsIdentity]::GetCurrent()
    $p  = New-Object Security.Principal.WindowsPrincipal($id)
    return $p.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

function Ensure-Directory {
    param([string]$Path)
    if (-not (Test-Path -LiteralPath $Path)) {
        New-Item -ItemType Directory -Path $Path -Force | Out-Null
    }
}

function Filter-ByCategory {
    param([object[]]$Items, [string]$Category)
    if (-not $Items) { return @() }
    return @($Items | Where-Object { $_.Category -eq $Category })
}

function Invoke-Collector {
    param(
        [string]$Name,
        [scriptblock]$Block,
        [ref]$Errors
    )
    try {
        $res = & $Block
        if ($null -eq $res) { return @() }
        return @($res)
    } catch {
        $Errors.Value += [pscustomobject]@{
            Collector = $Name
            Error     = $_.Exception.Message
        }
        return @()
    }
}

function Ensure-NormalizedForScore {
    param([object]$Item)
    if (-not $Item) { return $null }
    if ($Item -is [HostItem]) { return (Normalize-HostItem $Item) }
    return $Item
}

$admin = Test-IsAdmin
if (-not $admin) {
    Write-Host "[!] Recommended to run as Administrator for full coverage." -ForegroundColor Yellow
    $ans = Read-Host "Continue anyway? (Y/N) [N]"
    if ($ans.ToUpper() -ne 'Y') { exit 1 }
}

Ensure-Directory $OutputDir
Ensure-Directory $RefDir

$runMode = if ($Mode) {
    if ($Mode -eq '1') { 'Baseline' }
    elseif ($Mode -eq '2') { 'Compare' }
    else { $Mode }
} else {
    $choice = Read-Host "Select Mode: [1] Generate Baseline, [2] Compare State [2]"
    switch ($choice) {
        '1'        { 'Baseline' }
        'Baseline' { 'Baseline' }
        '2'        { 'Compare' }
        'Compare'  { 'Compare' }
        default    { 'Compare' }
    }
}

if ($runMode -eq 'Baseline') {
    & "$PSScriptRoot\Generate-OSBaseline.ps1" -OutputDir $RefDir -AllProfiles:$AllProfiles -ResolveNetworkPaths:$ResolveNetworkPaths -Firefox:$Firefox
    exit 0
}

$files = Get-ChildItem $RefDir -Filter *.json -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending
if (-not $files) { throw "No baseline files found in $RefDir" }

Write-Host "Select Reference:"
for ($i = 0; $i -lt $files.Count; $i++) {
    Write-Host " [$($i+1)] $($files[$i].Name)"
}

$sel = Read-Host "Choice [1]"
if ([string]::IsNullOrWhiteSpace($sel)) { $sel = '1' }
$idx = [int]$sel - 1
if ($idx -lt 0 -or $idx -ge $files.Count) { throw "Invalid selection." }

$baselinePath = $files[$idx].FullName
$baseJson     = Get-Content $baselinePath -Raw | ConvertFrom-Json
# Backward-compat: tolerate older baselines that don't include newer sections
if (-not ($baseJson.PSObject.Properties.Name -contains 'BrowserExtensions')) { $baseJson | Add-Member -NotePropertyName BrowserExtensions -NotePropertyValue @() }
if (-not ($baseJson.PSObject.Properties.Name -contains 'WmiPersistence'))     { $baseJson | Add-Member -NotePropertyName WmiPersistence -NotePropertyValue @() }
if (-not ($baseJson.PSObject.Properties.Name -contains 'NetworkSockets'))     { $baseJson | Add-Member -NotePropertyName NetworkSockets -NotePropertyValue @() }

Write-Host "[*] Running current snapshot..."
if (-not $IncludeRemoteSockets) {
    Write-Host "[*] NOTE: Sockets collection is LISTEN-only (low noise). Use -IncludeRemoteSockets to include full TCP connections."
}

$collectorErrors = @()

$current = [pscustomobject]@{
    Services          = (Invoke-Collector 'Services'  { Get-ServicesHostItems }       ([ref]$collectorErrors)) | ForEach-Object { Normalize-HostItem $_ }
    Drivers           = (Invoke-Collector 'Drivers'   { Get-DriversHostItems }        ([ref]$collectorErrors)) | ForEach-Object { Normalize-HostItem $_ }
    Processes         = (Invoke-Collector 'Processes' { Get-ProcessesHostItems }      ([ref]$collectorErrors)) | ForEach-Object { Normalize-HostItem $_ }
    ScheduledTasks    = (Invoke-Collector 'Tasks'     { Get-ScheduledTasksHostItems } ([ref]$collectorErrors)) | ForEach-Object { Normalize-HostItem $_ }
    Startup           = (Invoke-Collector 'Startup'   { Get-StartupHostItems -AllProfiles:$AllProfiles }        ([ref]$collectorErrors)) | ForEach-Object { Normalize-HostItem $_ }
    NetworkSockets    = (Invoke-Collector 'Sockets'   { Get-NetworkSocketsHostItems -IncludeRemoteSockets:$IncludeRemoteSockets } ([ref]$collectorErrors)) | ForEach-Object { Normalize-HostItem $_ }
    WmiPersistence    = (Invoke-Collector 'WMI'       { Get-WmiPersistenceHostItems } ([ref]$collectorErrors)) | ForEach-Object { Normalize-HostItem $_ }
    BrowserExtensions = (Invoke-Collector 'Browser'   { Get-BrowserExtensionsHostItems -Firefox:$Firefox } ([ref]$collectorErrors)) | ForEach-Object { Normalize-HostItem $_ }
}

$results = @(
    Compare-HostCategory -Category 'Services'       -Baseline $baseJson.Services       -Current $current.Services
    Compare-HostCategory -Category 'Drivers'        -Baseline $baseJson.Drivers        -Current $current.Drivers
    Compare-HostCategory -Category 'Processes'      -Baseline $baseJson.Processes      -Current $current.Processes      -IgnoreMetadataKeys @('ProcessIds','ParentProcessIds','Count')
    Compare-HostCategory -Category 'ScheduledTasks' -Baseline $baseJson.ScheduledTasks -Current $current.ScheduledTasks -IgnoreMetadataKeys @('LastRunTime','NextRunTime')
    Compare-HostCategory -Category 'Startup'        -Baseline $baseJson.Startup        -Current $current.Startup
    Compare-HostCategory -Category 'BrowserExtensions' -Baseline $baseJson.BrowserExtensions -Current $current.BrowserExtensions
    Compare-HostCategory -Category 'NetworkSockets' -Baseline $baseJson.NetworkSockets -Current $current.NetworkSockets

    Compare-HostCategory -Category 'WMI.Filter'     -Baseline (Filter-ByCategory $baseJson.WmiPersistence 'WMI.Filter')   -Current (Filter-ByCategory $current.WmiPersistence 'WMI.Filter')
    Compare-HostCategory -Category 'WMI.Consumer'   -Baseline (Filter-ByCategory $baseJson.WmiPersistence 'WMI.Consumer') -Current (Filter-ByCategory $current.WmiPersistence 'WMI.Consumer')
    Compare-HostCategory -Category 'WMI.Consumer.ActiveScript' -Baseline (Filter-ByCategory $baseJson.WmiPersistence 'WMI.Consumer.ActiveScript') -Current (Filter-ByCategory $current.WmiPersistence 'WMI.Consumer.ActiveScript')
    Compare-HostCategory -Category 'WMI.Binding'    -Baseline (Filter-ByCategory $baseJson.WmiPersistence 'WMI.Binding')  -Current (Filter-ByCategory $current.WmiPersistence 'WMI.Binding')
)

$findings = New-Object System.Collections.Generic.List[object]

foreach ($cat in $results) {
    foreach ($x in $cat.Added) {
        $nx = Ensure-NormalizedForScore $x
        $findings.Add([pscustomobject]@{
            Category = $cat.Category
            Type     = 'Added'
            Key      = $x.Key
            Score    = Score-HostItem $nx
            Item     = $x
        })
    }
    foreach ($x in $cat.Changed) {
        $nx = Ensure-NormalizedForScore $x.Current
        $findings.Add([pscustomobject]@{
            Category = $cat.Category
            Type     = 'Changed'
            Key      = $x.Key
            Score    = Score-HostItem $nx
            Item     = $x
        })
    }
    foreach ($x in $cat.Removed) {
        $nx = Ensure-NormalizedForScore $x
        $findings.Add([pscustomobject]@{
            Category = $cat.Category
            Type     = 'Removed'
            Key      = $x.Key
            Score    = Score-HostItem $nx
            Item     = $x
        })
    }
}

$report = [pscustomobject]@{
    Meta = @{
        SchemaVersion       = 2
        ComparedAtUtc       = (Get-Date).ToUniversalTime().ToString('o')
        BaselinePath        = $baselinePath
        ComputerName        = $env:COMPUTERNAME
        IncludeRemoteSockets= [bool]$IncludeRemoteSockets
        CollectorErrors     = $collectorErrors
    }
    Results        = $results
    RankedFindings = ($findings.ToArray() | Sort-Object Score -Descending)
}

$ts = (Get-Date).ToUniversalTime().ToString('yyyyMMddTHHmmssZ')
$reportPath = Join-Path $OutputDir "compare-report-$($env:COMPUTERNAME)-$ts.json"
$report | ConvertTo-Json -Depth 16 | Out-File $reportPath -Encoding UTF8

Write-Host "[+] Comparison complete. Report: $reportPath"
if ($collectorErrors.Count -gt 0) {
    Write-Host "[!] Collector warnings/errors were recorded in report Meta.CollectorErrors" -ForegroundColor Yellow
}
